package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

// Структуры данных
type (
	UserProfilePhotos struct {
		Result struct {
			TotalCount int `json:"total_count"`
			Photos     [][]struct {
				FileID string `json:"file_id"`
			} `json:"photos"`
		} `json:"result"`
	}

	FileResponse struct {
		Result struct {
			FilePath string `json:"file_path"`
		} `json:"result"`
	}

	User struct {
		UserID          int64     `json:"userID"`
		UserFirstName   string    `json:"userFirstName"`
		UserLastName    string    `json:"userLastName,omitempty"`
		Username        string    `json:"username,omitempty"`
		PhoneNumber     string    `json:"phoneNumber,omitempty"`
		RegistrationDate time.Time `json:"registrationDate"`
	}

	UsersData struct {
		Users []User `json:"users"`
	}

	Message struct {
		UserID      int64     `json:"userID"`
		MessageID   int       `json:"messageID"`
		Text        string    `json:"text,omitempty"`
		PhotoIDs    []string  `json:"photoIDs,omitempty"`
		PhotoPaths  []string  `json:"photoPaths,omitempty"`
		MessageDate time.Time `json:"messageDate"`
	}

	MessagesData struct {
		Messages []Message `json:"messages"`
	}

	BotContext struct {
		Bot            *tgbotapi.BotAPI
		UsersDataFile  string
		MessagesDataFile string
	}
)

// Инициализация бота
func initBot(token string) (*tgbotapi.BotAPI, error) {
	bot, err := tgbotapi.NewBotAPI(token)
	if err != nil {
		return nil, fmt.Errorf("ошибка инициализации бота: %v", err)
	}
	bot.Debug = false
	log.Printf("Подключился %s", bot.Self.UserName)
	return bot, nil
}

// Работа с файлами данных
func loadJSONData(filename string, target interface{}) error {
	if _, err := os.Stat(filename); os.IsNotExist(err) {
		return nil
	}

	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return json.NewDecoder(file).Decode(target)
}

func saveJSONData(filename string, data interface{}) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(data)
}

// Обработка пользователей
func handleUserRegistration(ctx *BotContext, update tgbotapi.Update) error {
	usersData := UsersData{}
	if err := loadJSONData(ctx.UsersDataFile, &usersData); err != nil {
		return err
	}

	from := update.Message.From
	userID := from.ID

	// Проверка существования пользователя
	var userExists bool
	var existingUserIndex int
	for i, user := range usersData.Users {
		if user.UserID == userID {
			userExists = true
			existingUserIndex = i
			break
		}
	}

	// Обработка контакта
	if update.Message.Contact != nil {
		phoneNumber := update.Message.Contact.PhoneNumber

		if userExists {
			usersData.Users[existingUserIndex].PhoneNumber = phoneNumber
		} else {
			usersData.Users = append(usersData.Users, User{
				UserID:          userID,
				UserFirstName:   from.FirstName,
				UserLastName:    from.LastName,
				Username:        from.UserName,
				PhoneNumber:     phoneNumber,
				RegistrationDate: time.Now(),
			})
		}

		if err := saveJSONData(ctx.UsersDataFile, usersData); err != nil {
			return err
		}

		msg := tgbotapi.NewMessage(update.Message.Chat.ID, "Номер телефона сохранен!")
		msg.ReplyToMessageID = update.Message.MessageID
		_, err := ctx.Bot.Send(msg)
		return err
	}

	// Регистрация нового пользователя
	if !userExists {
		usersData.Users = append(usersData.Users, User{
			UserID:          userID,
			UserFirstName:   from.FirstName,
			UserLastName:    from.LastName,
			Username:        from.UserName,
			RegistrationDate: time.Now(),
		})

		return saveJSONData(ctx.UsersDataFile, usersData)
	}

	return nil
}

// Обработка сообщений
func handleMessage(ctx *BotContext, update tgbotapi.Update) error {
	messagesData := MessagesData{}
	if err := loadJSONData(ctx.MessagesDataFile, &messagesData); err != nil {
		return err
	}

	newMessage := Message{
		UserID:      update.Message.From.ID,
		MessageID:   update.Message.MessageID,
		Text:        update.Message.Text,
		MessageDate: time.Now(),
	}

	// Обработка фото
	if len(update.Message.Photo) > 0 {
		photo := update.Message.Photo[len(update.Message.Photo)-1]
		newMessage.PhotoIDs = append(newMessage.PhotoIDs, photo.FileID)

		if photoPath, err := saveMessagePhoto(ctx.Bot.Token, photo.FileID); err == nil {
			newMessage.PhotoPaths = append(newMessage.PhotoPaths, photoPath)
		} else {
			log.Printf("Ошибка сохранения фото: %v", err)
		}
	}

	messagesData.Messages = append(messagesData.Messages, newMessage)
	return saveJSONData(ctx.MessagesDataFile, messagesData)
}

// Работа с медиафайлами
func saveMessagePhoto(botToken, fileID string) (string, error) {
	fileInfoURL := fmt.Sprintf("https://api.telegram.org/bot%s/getFile?file_id=%s", botToken, fileID)
	resp, err := http.Get(fileInfoURL)
	if err != nil {
		return "", fmt.Errorf("ошибка при запросе к getFile: %v", err)
	}
	defer resp.Body.Close()

	var fileResponse FileResponse
	if err := json.NewDecoder(resp.Body).Decode(&fileResponse); err != nil {
		return "", fmt.Errorf("ошибка декодирования JSON: %v", err)
	}

	fileURL := fmt.Sprintf("https://api.telegram.org/file/bot%s/%s", botToken, fileResponse.Result.FilePath)
	if _, err := os.Stat("photos"); os.IsNotExist(err) {
		os.Mkdir("photos", 0755)
	}

	resp, err = http.Get(fileURL)
	if err != nil {
		return "", fmt.Errorf("ошибка скачивания файла: %v", err)
	}
	defer resp.Body.Close()

	filename := fmt.Sprintf("photos/%s_%d.jpg", fileID, time.Now().Unix())
	out, err := os.Create(filename)
	if err != nil {
		return "", fmt.Errorf("ошибка создания файла: %v", err)
	}
	defer out.Close()

	if _, err = io.Copy(out, resp.Body); err != nil {
		return "", fmt.Errorf("ошибка записи файла: %v", err)
	}

	return filename, nil
}

func getUserAvatar(botToken, userID string) (string, error) {
	photosURL := fmt.Sprintf("https://api.telegram.org/bot%s/getUserProfilePhotos?user_id=%s", botToken, userID)
	resp, err := http.Get(photosURL)
	if err != nil {
		return "", fmt.Errorf("ошибка запроса к API: %v", err)
	}
	defer resp.Body.Close()

	var userProfilePhotos UserProfilePhotos
	if err := json.NewDecoder(resp.Body).Decode(&userProfilePhotos); err != nil {
		return "", fmt.Errorf("ошибка декодирования JSON: %v", err)
	}

	if userProfilePhotos.Result.TotalCount == 0 {
		return "у пользователя нет аватара", nil
	}

	fileID := userProfilePhotos.Result.Photos[0][0].FileID
	fileInfoURL := fmt.Sprintf("https://api.telegram.org/bot%s/getFile?file_id=%s", botToken, fileID)
	resp, err = http.Get(fileInfoURL)
	if err != nil {
		return "", fmt.Errorf("ошибка запроса к getFile: %v", err)
	}
	defer resp.Body.Close()

	var fileResponse FileResponse
	if err := json.NewDecoder(resp.Body).Decode(&fileResponse); err != nil {
		return "", fmt.Errorf("ошибка декодирования JSON: %v", err)
	}

	fileURL := fmt.Sprintf("https://api.telegram.org/file/bot%s/%s", botToken, fileResponse.Result.FilePath)
	resp, err = http.Get(fileURL)
	if err != nil {
		return "", fmt.Errorf("ошибка скачивания файла: %v", err)
	}
	defer resp.Body.Close()

	filename := userID + ".jpg"
	out, err := os.Create(filename)
	if err != nil {
		return "", fmt.Errorf("ошибка создания файла: %v", err)
	}
	defer out.Close()

	if _, err = io.Copy(out, resp.Body); err != nil {
		return "", fmt.Errorf("ошибка записи файла: %v", err)
	}

	return fmt.Sprintf("аватар успешно скачан как %s", filename), nil
}

// Формирование ответа
func generateReply(update tgbotapi.Update, message Message) string {
	from := update.Message.From
	replyText := "Получены следующие данные:\n\n"
	replyText += fmt.Sprintf("Текст сообщения: %s\n", update.Message.Text)
	replyText += fmt.Sprintf("ID сообщения: %d\n", update.Message.MessageID)
	replyText += fmt.Sprintf("Имя пользователя: %s\n", from.FirstName)
	replyText += fmt.Sprintf("Фамилия пользователя: %s\n", from.LastName)
	replyText += fmt.Sprintf("Никнейм пользователя: %s\n", from.UserName)
	replyText += fmt.Sprintf("ID пользователя: %d\n", from.ID)

	if len(message.PhotoIDs) > 0 {
		replyText += "К сообщению прикреплено фото\n"
	}

	avatarInfo, err := getUserAvatar("YOUR_BOT_TOKEN", strconv.FormatInt(from.ID, 10))
	if err != nil {
		replyText += fmt.Sprintf("\nИнформация об аватаре: %s", err.Error())
	} else {
		replyText += fmt.Sprintf("\nИнформация об аватаре: %s", avatarInfo)
	}

	return replyText
}

// Основная функция
func main() {
	bot, err := initBot("7217078454:AAGqrgEr_JuoJnwqwf1xU5P3lO--GnDtCIg")
	if err != nil {
		log.Panic(err)
	}

	ctx := &BotContext{
		Bot:            bot,
		UsersDataFile:  "users_data.json",
		MessagesDataFile: "messages_data.json",
	}

	u := tgbotapi.NewUpdate(0)
	u.Timeout = 10
	updates := bot.GetUpdatesChan(u)

	for update := range updates {
		if update.Message == nil {
			continue
		}

		// Обработка пользователя
		if err := handleUserRegistration(ctx, update); err != nil {
			log.Printf("Ошибка обработки пользователя: %v", err)
		}

		// Обработка сообщения
		if err := handleMessage(ctx, update); err != nil {
			log.Printf("Ошибка обработки сообщения: %v", err)
		}

		// Формирование и отправка ответа
		msg := tgbotapi.NewMessage(update.Message.Chat.ID, generateReply(update, Message{
			UserID:    update.Message.From.ID,
			MessageID: update.Message.MessageID,
			Text:      update.Message.Text,
		}))
		msg.ReplyToMessageID = update.Message.MessageID

		if _, err := bot.Send(msg); err != nil {
			log.Printf("Ошибка отправки сообщения: %v", err)
		}
	}
}